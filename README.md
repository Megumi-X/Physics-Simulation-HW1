
We use C++ and Python as the main programming languages. Specifically, we implement the simulation backend in C++ and wrap the interface into a Python package. To achieve this, we require external C++ libraries Eigen 3.4.90 and pybind11 2.11.1, provided in the folder `external`. For visualization, we choose Open3D 0.18.0, to be installed by pip. You may refer to the official documentation: https://eigen.tuxfamily.org/ , https://pybind11.readthedocs.io/en/stable/ , and https://www.open3d.org/docs/release/ .
## Installation
To run the code, firstly install Python>=3.8. For example in a Conda environment, you could run
```
conda create -n homework1 python=3.10
conda activate homework1
```
To install necessary packages and compile the C++ backend, you simply run `pip install .` in the root directory of our codebase (where there is a `setup.py`). Whenever you change any C++ code, remember to rerun `pip install .` before you run any Python scripts.

## Cpp Code
The simulator is implemented the `Simulator` class, found in `simulator.hpp`. After correctly configuring the system by calling `AddLink`, we are able to call the `Forward` function to evolute the system by one time step. Link poses could be queried by the interface `link_pose` afterwards. This API may be confusing: it refers to the pose relative to the initial canonical frame. To be specific: begin with the object when you are adding it to the simulator, first translate your object so that the center of mass is at the origin, then apply the transform acquired by `link_pose` should give you the correct configuration of the object. It is a template class that is instantiated in 2D and 3D separately. Although the interfaces are the same, you may notice that some private functions in `simulator.cpp` are implemented differently in 2D and 3D.

Besides, the homogeneous transformation is implemented in the class `RigidTransform` found in `rigid_transform.hpp`, and different types of joints are implemented with polymorphism. All joints are inherited from the base class defined in `joint.hpp`, where a numerical test function is also provided.

In `common.hpp`, a useful `Assert` function is provided for you to debug your code, so that the Python frontend would be able to catch the RuntimeError triggered by the dynamic assertion failure. Also be sure you notice the aliases defined in `common.hpp`, which are slightly different from the conventions in the namespace Eigen. Note we adopt Eigen for basic matrix operator, where the convention may be different from NumPy or Matlab. 

You may refer to the `main.cpp` to see what interfaces in C++ are exposed to Python. If you would like to expose more APIs to Python for debugging, you may refer to the official document of pybind11 and add them here correspondingly. For now, the numerical test functions (generated by macros in `joint.hpp`) and the instantiated classes `RigidTransform` and `Simulator` are exposed to Python. See the `Type annotations` section if you want the APIs to be understood by your IDLE.


## Trouble-shooting
### On Windows or MacOS
We do not officially guarantee that the installation on a Windows or MacOS system is bugfree for every homework, so prepare a Ubuntu environment is recommended for this course. For this homework, fortunately, it is tested on a Windows laptop that a simple `pip install .` works as expected after Python 3.9 and VS2019 installed.

### Type annotations
If you would like to automatically generate the type annotation for the backend package, you may try the following commands in the root directory of the code base:
```
pip install pybind11-stubgen
pybind11-stubgen backend -o=. --numpy-array-remove-parameters --ignore-all-errors
```
It will automatically generate a file `backend.pyi` that explains the exposed APIs to your IDLE.

### Ubuntu server without a display
You may encounter some error in visualization if you're using a Ubuntu server without a display. The visualization is not mandatory for this homework and is independent from the simulation. One possible solution: 1) run the `gyroscope_simulation.py` on your server, 2) download the stored link poses `r.npy`, 3) run `gyroscope_visualization.py` on your own laptop.